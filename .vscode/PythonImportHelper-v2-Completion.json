[
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "core",
        "importPath": "pgsrip",
        "description": "pgsrip",
        "isExtraImport": true,
        "detail": "pgsrip",
        "documentation": {}
    },
    {
        "label": "Pgs",
        "importPath": "pgsrip",
        "description": "pgsrip",
        "isExtraImport": true,
        "detail": "pgsrip",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "pgsrip",
        "description": "pgsrip",
        "isExtraImport": true,
        "detail": "pgsrip",
        "documentation": {}
    },
    {
        "label": "api",
        "importPath": "pgsrip",
        "description": "pgsrip",
        "isExtraImport": true,
        "detail": "pgsrip",
        "documentation": {}
    },
    {
        "label": "Media",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Pgs",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Media",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Media",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Pgs",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Media",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Pgs",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Pgs",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "PgsSubtitleItem",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Media",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Pgs",
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "isExtraImport": true,
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "SubtitleTypeFilter",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "SubtitleTypeFilter",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "TesseractEngineMode",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "TesseractPageSegmentationMode",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "isExtraImport": true,
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "Error",
        "importPath": "babelfish",
        "description": "babelfish",
        "isExtraImport": true,
        "detail": "babelfish",
        "documentation": {}
    },
    {
        "label": "Language",
        "importPath": "babelfish",
        "description": "babelfish",
        "isExtraImport": true,
        "detail": "babelfish",
        "documentation": {}
    },
    {
        "label": "Language",
        "importPath": "babelfish",
        "description": "babelfish",
        "isExtraImport": true,
        "detail": "babelfish",
        "documentation": {}
    },
    {
        "label": "Language",
        "importPath": "babelfish",
        "description": "babelfish",
        "isExtraImport": true,
        "detail": "babelfish",
        "documentation": {}
    },
    {
        "label": "Language",
        "importPath": "babelfish",
        "description": "babelfish",
        "isExtraImport": true,
        "detail": "babelfish",
        "documentation": {}
    },
    {
        "label": "Language",
        "importPath": "babelfish",
        "description": "babelfish",
        "isExtraImport": true,
        "detail": "babelfish",
        "documentation": {}
    },
    {
        "label": "click",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "click",
        "description": "click",
        "detail": "click",
        "documentation": {}
    },
    {
        "label": "pytesseract",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytesseract",
        "description": "pytesseract",
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "Mkv",
        "importPath": "pgsrip.mkv",
        "description": "pgsrip.mkv",
        "isExtraImport": true,
        "detail": "pgsrip.mkv",
        "documentation": {}
    },
    {
        "label": "PgsToSrtRipper",
        "importPath": "pgsrip.ripper",
        "description": "pgsrip.ripper",
        "isExtraImport": true,
        "detail": "pgsrip.ripper",
        "documentation": {}
    },
    {
        "label": "Sup",
        "importPath": "pgsrip.sup",
        "description": "pgsrip.sup",
        "isExtraImport": true,
        "detail": "pgsrip.sup",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "MediaPath",
        "importPath": "pgsrip.media_path",
        "description": "pgsrip.media_path",
        "isExtraImport": true,
        "detail": "pgsrip.media_path",
        "documentation": {}
    },
    {
        "label": "MediaPath",
        "importPath": "pgsrip.media_path",
        "description": "pgsrip.media_path",
        "isExtraImport": true,
        "detail": "pgsrip.media_path",
        "documentation": {}
    },
    {
        "label": "MediaPath",
        "importPath": "pgsrip.media_path",
        "description": "pgsrip.media_path",
        "isExtraImport": true,
        "detail": "pgsrip.media_path",
        "documentation": {}
    },
    {
        "label": "MediaPath",
        "importPath": "pgsrip.media_path",
        "description": "pgsrip.media_path",
        "isExtraImport": true,
        "detail": "pgsrip.media_path",
        "documentation": {}
    },
    {
        "label": "DisplaySet",
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "isExtraImport": true,
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "Palette",
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "isExtraImport": true,
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "PgsImage",
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "isExtraImport": true,
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "PgsReader",
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "isExtraImport": true,
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "pairwise",
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "isExtraImport": true,
        "detail": "pgsrip.utils",
        "documentation": {}
    },
    {
        "label": "from_hex",
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "isExtraImport": true,
        "detail": "pgsrip.utils",
        "documentation": {}
    },
    {
        "label": "safe_get",
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "isExtraImport": true,
        "detail": "pgsrip.utils",
        "documentation": {}
    },
    {
        "label": "to_time",
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "isExtraImport": true,
        "detail": "pgsrip.utils",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "check_output",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "trakit",
        "importPath": "trakit.api",
        "description": "trakit.api",
        "isExtraImport": true,
        "detail": "trakit.api",
        "documentation": {}
    },
    {
        "label": "enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "enum",
        "description": "enum",
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "cleanit",
        "description": "cleanit",
        "isExtraImport": true,
        "detail": "cleanit",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "ndarray",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "SubRipFile",
        "importPath": "pysrt",
        "description": "pysrt",
        "isExtraImport": true,
        "detail": "pysrt",
        "documentation": {}
    },
    {
        "label": "SubRipItem",
        "importPath": "pysrt",
        "description": "pysrt",
        "isExtraImport": true,
        "detail": "pysrt",
        "documentation": {}
    },
    {
        "label": "SubRipTime",
        "importPath": "pysrt",
        "description": "pysrt",
        "isExtraImport": true,
        "detail": "pysrt",
        "documentation": {}
    },
    {
        "label": "TsvData",
        "importPath": "pgsrip.tsv",
        "description": "pgsrip.tsv",
        "isExtraImport": true,
        "detail": "pgsrip.tsv",
        "documentation": {}
    },
    {
        "label": "scan_path",
        "kind": 2,
        "importPath": "pgsrip.api",
        "description": "pgsrip.api",
        "peekOfCode": "def scan_path(path: str, options: typing.Optional[Options] = None):\n    collected: typing.List[Media] = []\n    filtered_out: typing.List[str] = []\n    discarded: typing.List[str] = []\n    core.scan_path(path, collected, filtered_out, discarded, options=options or Options())\n    return collected, filtered_out, discarded\ndef rip(media: Media, options: typing.Optional[Options] = None):\n    return core.rip(media, options or Options())\ndef rip_pgs(pgs: Pgs, options: typing.Optional[Options] = None):\n    return core.rip_pgs(pgs, options or Options())",
        "detail": "pgsrip.api",
        "documentation": {}
    },
    {
        "label": "rip",
        "kind": 2,
        "importPath": "pgsrip.api",
        "description": "pgsrip.api",
        "peekOfCode": "def rip(media: Media, options: typing.Optional[Options] = None):\n    return core.rip(media, options or Options())\ndef rip_pgs(pgs: Pgs, options: typing.Optional[Options] = None):\n    return core.rip_pgs(pgs, options or Options())",
        "detail": "pgsrip.api",
        "documentation": {}
    },
    {
        "label": "rip_pgs",
        "kind": 2,
        "importPath": "pgsrip.api",
        "description": "pgsrip.api",
        "peekOfCode": "def rip_pgs(pgs: Pgs, options: typing.Optional[Options] = None):\n    return core.rip_pgs(pgs, options or Options())",
        "detail": "pgsrip.api",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.api",
        "description": "pgsrip.api",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef scan_path(path: str, options: typing.Optional[Options] = None):\n    collected: typing.List[Media] = []\n    filtered_out: typing.List[str] = []\n    discarded: typing.List[str] = []\n    core.scan_path(path, collected, filtered_out, discarded, options=options or Options())\n    return collected, filtered_out, discarded\ndef rip(media: Media, options: typing.Optional[Options] = None):\n    return core.rip(media, options or Options())\ndef rip_pgs(pgs: Pgs, options: typing.Optional[Options] = None):",
        "detail": "pgsrip.api",
        "documentation": {}
    },
    {
        "label": "DebugProgressBar",
        "kind": 6,
        "importPath": "pgsrip.cli",
        "description": "pgsrip.cli",
        "peekOfCode": "class DebugProgressBar(typing.Generic[T]):\n    def __init__(self, debug: bool, iterable: typing.Iterable[T], **kwargs):\n        self.debug = debug\n        self.iterable = iterable\n        self.progressbar = click.progressbar(iterable, **kwargs)\n    def __iter__(self):\n        if not self.debug:\n            return self.progressbar.__iter__()\n        yield from self.iterable\n    def __enter__(self):",
        "detail": "pgsrip.cli",
        "documentation": {}
    },
    {
        "label": "LanguageParamType",
        "kind": 6,
        "importPath": "pgsrip.cli",
        "description": "pgsrip.cli",
        "peekOfCode": "class LanguageParamType(click.ParamType):\n    name = 'language'\n    def convert(self, value, param, ctx):\n        try:\n            return Language.fromietf(value)\n        except (BabelfishError, ValueError):\n            self.fail(f\"{click.style(f'{value}', bold=True)} is not a valid language\")\nclass AgeParamType(click.ParamType):\n    name = 'age'\n    def convert(self, value, param, ctx):",
        "detail": "pgsrip.cli",
        "documentation": {}
    },
    {
        "label": "AgeParamType",
        "kind": 6,
        "importPath": "pgsrip.cli",
        "description": "pgsrip.cli",
        "peekOfCode": "class AgeParamType(click.ParamType):\n    name = 'age'\n    def convert(self, value, param, ctx):\n        match = re.match(r'^(?:(?P<weeks>\\d+?)w)?(?:(?P<days>\\d+?)d)?(?:(?P<hours>\\d+?)h)?$', value)\n        if not match:\n            self.fail('%s is not a valid age' % value)\n        return timedelta(**{k: int(v) for k, v in match.groupdict('0').items()})\nLANGUAGE = LanguageParamType()\nAGE = AgeParamType()\n@click.command()",
        "detail": "pgsrip.cli",
        "documentation": {}
    },
    {
        "label": "pgsrip",
        "kind": 2,
        "importPath": "pgsrip.cli",
        "description": "pgsrip.cli",
        "peekOfCode": "def pgsrip(config: typing.Optional[str],\n           language: typing.Optional[typing.Tuple[Language]],\n           tag: typing.Optional[typing.Tuple[str]],\n           encoding: typing.Optional[str],\n           age: typing.Optional[timedelta],\n           srt_age: typing.Optional[timedelta],\n           subtitle_type_filter: typing.Optional[str],\n           force: bool,\n           all: bool,\n           debug: bool,",
        "detail": "pgsrip.cli",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.cli",
        "description": "pgsrip.cli",
        "peekOfCode": "logger = logging.getLogger('pgsrip')\nT = typing.TypeVar('T')\nclass DebugProgressBar(typing.Generic[T]):\n    def __init__(self, debug: bool, iterable: typing.Iterable[T], **kwargs):\n        self.debug = debug\n        self.iterable = iterable\n        self.progressbar = click.progressbar(iterable, **kwargs)\n    def __iter__(self):\n        if not self.debug:\n            return self.progressbar.__iter__()",
        "detail": "pgsrip.cli",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "pgsrip.cli",
        "description": "pgsrip.cli",
        "peekOfCode": "T = typing.TypeVar('T')\nclass DebugProgressBar(typing.Generic[T]):\n    def __init__(self, debug: bool, iterable: typing.Iterable[T], **kwargs):\n        self.debug = debug\n        self.iterable = iterable\n        self.progressbar = click.progressbar(iterable, **kwargs)\n    def __iter__(self):\n        if not self.debug:\n            return self.progressbar.__iter__()\n        yield from self.iterable",
        "detail": "pgsrip.cli",
        "documentation": {}
    },
    {
        "label": "LANGUAGE",
        "kind": 5,
        "importPath": "pgsrip.cli",
        "description": "pgsrip.cli",
        "peekOfCode": "LANGUAGE = LanguageParamType()\nAGE = AgeParamType()\n@click.command()\n@click.option('-c', '--config', type=click.Path(), help='cleanit configuration path to be used')\n@click.option('-l', '--language', type=LANGUAGE, multiple=True, help='Language as IETF code, '\n              'e.g. en, pt-BR (can be used multiple times).')\n@click.option('-t', '--tag', required=False, multiple=True, help='Rule tags to be used, '\n              'e.g. ocr, tidy, no-sdh, no-style, no-lyrics, no-spam (can be used multiple times). ')\n@click.option('-e', '--encoding', help='Save subtitles using the following encoding.')\n@click.option('-a', '--age', type=AGE, help='Filter videos newer than AGE, e.g. 12h, 1w2d.')",
        "detail": "pgsrip.cli",
        "documentation": {}
    },
    {
        "label": "AGE",
        "kind": 5,
        "importPath": "pgsrip.cli",
        "description": "pgsrip.cli",
        "peekOfCode": "AGE = AgeParamType()\n@click.command()\n@click.option('-c', '--config', type=click.Path(), help='cleanit configuration path to be used')\n@click.option('-l', '--language', type=LANGUAGE, multiple=True, help='Language as IETF code, '\n              'e.g. en, pt-BR (can be used multiple times).')\n@click.option('-t', '--tag', required=False, multiple=True, help='Rule tags to be used, '\n              'e.g. ocr, tidy, no-sdh, no-style, no-lyrics, no-spam (can be used multiple times). ')\n@click.option('-e', '--encoding', help='Save subtitles using the following encoding.')\n@click.option('-a', '--age', type=AGE, help='Filter videos newer than AGE, e.g. 12h, 1w2d.')\n@click.option('-A', '--srt-age', type=AGE, help='Filter videos which srt subtitles are newer than AGE, e.g. 12h, 1w2d.')",
        "detail": "pgsrip.cli",
        "documentation": {}
    },
    {
        "label": "scan_path",
        "kind": 2,
        "importPath": "pgsrip.core",
        "description": "pgsrip.core",
        "peekOfCode": "def scan_path(path: str,\n              collected: typing.List[Media],\n              filtered_out: typing.List[str],\n              discarded: typing.List[str],\n              options: Options):\n    if not os.path.exists(path):\n        logger.debug('Non existent path %s discarded', path)\n        discarded.append(path)\n    elif os.path.isfile(path):\n        if path.lower().endswith(EXTENSIONS):",
        "detail": "pgsrip.core",
        "documentation": {}
    },
    {
        "label": "rip",
        "kind": 2,
        "importPath": "pgsrip.core",
        "description": "pgsrip.core",
        "peekOfCode": "def rip(media: Media, options: Options):\n    counter = 0\n    for pgs in media.get_pgs_medias(options):\n        counter += rip_pgs(pgs, options)\n    return counter\ndef rip_pgs(pgs: Pgs, options: Options):\n    # noinspection PyBroadException\n    try:\n        with pgs as p:\n            if not p.matches(options):",
        "detail": "pgsrip.core",
        "documentation": {}
    },
    {
        "label": "rip_pgs",
        "kind": 2,
        "importPath": "pgsrip.core",
        "description": "pgsrip.core",
        "peekOfCode": "def rip_pgs(pgs: Pgs, options: Options):\n    # noinspection PyBroadException\n    try:\n        with pgs as p:\n            if not p.matches(options):\n                return False\n            rules = options.config.select_rules(tags=options.tags, languages={p.language})\n            srt = PgsToSrtRipper(p, options).rip(lambda t: rules.apply(t, '')[0])\n            srt.save(encoding=options.encoding)\n            return True",
        "detail": "pgsrip.core",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.core",
        "description": "pgsrip.core",
        "peekOfCode": "logger = logging.getLogger(__name__)\nMEDIAS: typing.Dict[str, typing.Union[typing.Type[Sup], typing.Type[Mkv]]] = {\n    '.sup': Sup,\n    '.mkv': Mkv,\n    '.mks': Mkv\n}\nEXTENSIONS = tuple(MEDIAS.keys())\ndef scan_path(path: str,\n              collected: typing.List[Media],\n              filtered_out: typing.List[str],",
        "detail": "pgsrip.core",
        "documentation": {}
    },
    {
        "label": "EXTENSIONS",
        "kind": 5,
        "importPath": "pgsrip.core",
        "description": "pgsrip.core",
        "peekOfCode": "EXTENSIONS = tuple(MEDIAS.keys())\ndef scan_path(path: str,\n              collected: typing.List[Media],\n              filtered_out: typing.List[str],\n              discarded: typing.List[str],\n              options: Options):\n    if not os.path.exists(path):\n        logger.debug('Non existent path %s discarded', path)\n        discarded.append(path)\n    elif os.path.isfile(path):",
        "detail": "pgsrip.core",
        "documentation": {}
    },
    {
        "label": "PgsSubtitleItem",
        "kind": 6,
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "peekOfCode": "class PgsSubtitleItem:\n    def __init__(self,\n                 index: int,\n                 media_path: MediaPath,\n                 display_sets: typing.List[DisplaySet]):\n        self.index = index\n        self.media_path = media_path\n        self.start = min([ds.pcs.presentation_timestamp for ds in display_sets] or [None])\n        self.end = max([ds.pcs.presentation_timestamp for ds in display_sets] or [None])\n        self.image = PgsSubtitleItem.generate_image(display_sets)",
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Pgs",
        "kind": 6,
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "peekOfCode": "class Pgs:\n    def __init__(self,\n                 media_path: MediaPath,\n                 options: Options,\n                 data_reader: typing.Callable[[], bytes],\n                 temp_folder: str):\n        self.media_path = media_path\n        self.options = options\n        self.data_reader = data_reader\n        self.temp_folder = temp_folder",
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "Media",
        "kind": 6,
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "peekOfCode": "class Media(ABC):\n    def __init__(self, media_path: MediaPath, languages: typing.Set[Language]):\n        self.name = str(media_path)\n        self.media_path = media_path\n        self.languages = languages\n    def __repr__(self):\n        return f'<{self.__class__.__name__} [{self.media_path}]>'\n    def __str__(self):\n        return str(self.media_path)\n    @property",
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.media",
        "description": "pgsrip.media",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass PgsSubtitleItem:\n    def __init__(self,\n                 index: int,\n                 media_path: MediaPath,\n                 display_sets: typing.List[DisplaySet]):\n        self.index = index\n        self.media_path = media_path\n        self.start = min([ds.pcs.presentation_timestamp for ds in display_sets] or [None])\n        self.end = max([ds.pcs.presentation_timestamp for ds in display_sets] or [None])",
        "detail": "pgsrip.media",
        "documentation": {}
    },
    {
        "label": "MediaPath",
        "kind": 6,
        "importPath": "pgsrip.media_path",
        "description": "pgsrip.media_path",
        "peekOfCode": "class MediaPath:\n    def __init__(self, path: str, subtitle_type: typing.Optional[str] = None):\n        file_part, extension = os.path.splitext(path)\n        base_path, code = os.path.splitext(file_part)\n        self.number = 0\n        self.language = Language.fromcleanit(code[1:] if code else 'und')\n        self.extension = extension[1:] if extension else None\n        self.base_path = base_path if self.language else file_part\n        self.subtitle_type = subtitle_type\n    def __repr__(self):",
        "detail": "pgsrip.media_path",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.media_path",
        "description": "pgsrip.media_path",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass MediaPath:\n    def __init__(self, path: str, subtitle_type: typing.Optional[str] = None):\n        file_part, extension = os.path.splitext(path)\n        base_path, code = os.path.splitext(file_part)\n        self.number = 0\n        self.language = Language.fromcleanit(code[1:] if code else 'und')\n        self.extension = extension[1:] if extension else None\n        self.base_path = base_path if self.language else file_part\n        self.subtitle_type = subtitle_type",
        "detail": "pgsrip.media_path",
        "documentation": {}
    },
    {
        "label": "MkvPgs",
        "kind": 6,
        "importPath": "pgsrip.mkv",
        "description": "pgsrip.mkv",
        "peekOfCode": "class MkvPgs(Pgs):\n    @classmethod\n    def read_data(cls, media_path: MediaPath, track_id: int, temp_folder: str):\n        lang_ext = f'.{str(media_path.language)}' if media_path.language else ''\n        sup_file = os.path.join(temp_folder, f'{track_id}{lang_ext}.sup')\n        cmd = ['mkvextract', str(media_path), 'tracks', f'{track_id}:{sup_file}']\n        check_output(cmd)\n        with open(sup_file, mode='rb') as f:\n            return f.read()\n    def __init__(self, media_path: MediaPath, track_id: int, language: Language, number: int, options: Options):",
        "detail": "pgsrip.mkv",
        "documentation": {}
    },
    {
        "label": "MkvTrack",
        "kind": 6,
        "importPath": "pgsrip.mkv",
        "description": "pgsrip.mkv",
        "peekOfCode": "class MkvTrack:\n    def __init__(self, track: dict):\n        self.id = track['id']\n        self.type = track['type']\n        self.codec = track['codec']\n        self.properties = track.get('properties', {})\n    @property\n    def enabled(self):\n        return self.properties.get('enabled_track')\n    @property",
        "detail": "pgsrip.mkv",
        "documentation": {}
    },
    {
        "label": "Mkv",
        "kind": 6,
        "importPath": "pgsrip.mkv",
        "description": "pgsrip.mkv",
        "peekOfCode": "class Mkv(Media):\n    def __init__(self, path: str):\n        metadata = json.loads(check_output(['mkvmerge', '-i', '-F', 'json', path]))\n        tracks = [MkvTrack(t) for t in metadata.get('tracks', [])]\n        super().__init__(MediaPath(path), languages={t.language for t in tracks})\n        self.tracks = tracks\n    def get_pgs_medias(self, options: Options):\n            try:\n                # NEW LOGIC: Try the enhanced implementation with RipAllTracks support\n                tracks = [t for t in self.tracks",
        "detail": "pgsrip.mkv",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.mkv",
        "description": "pgsrip.mkv",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass MkvPgs(Pgs):\n    @classmethod\n    def read_data(cls, media_path: MediaPath, track_id: int, temp_folder: str):\n        lang_ext = f'.{str(media_path.language)}' if media_path.language else ''\n        sup_file = os.path.join(temp_folder, f'{track_id}{lang_ext}.sup')\n        cmd = ['mkvextract', str(media_path), 'tracks', f'{track_id}:{sup_file}']\n        check_output(cmd)\n        with open(sup_file, mode='rb') as f:\n            return f.read()",
        "detail": "pgsrip.mkv",
        "documentation": {}
    },
    {
        "label": "TesseractEngineMode",
        "kind": 6,
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "peekOfCode": "class TesseractEngineMode(enum.Enum):\n    LEGACY = 0\n    NEURAL = 1\n    LEGACY_AND_NEURAL = 2\n    DEFAULT_AVAILABLE = 3\n@enum.unique\nclass TesseractPageSegmentationMode(enum.Enum):\n    OSD_ONLY = 0\n    AUTOMATIC_PAGE_SEGMENTATION_WITH_OSD = 1\n    AUTOMATIC_PAGE_SEGMENTATION_WITHOUT_OSD_OR_OCR = 2",
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "TesseractPageSegmentationMode",
        "kind": 6,
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "peekOfCode": "class TesseractPageSegmentationMode(enum.Enum):\n    OSD_ONLY = 0\n    AUTOMATIC_PAGE_SEGMENTATION_WITH_OSD = 1\n    AUTOMATIC_PAGE_SEGMENTATION_WITHOUT_OSD_OR_OCR = 2\n    FULLY_AUTOMATIC_PAGE_SEGMENTATION_WITHOUT_OSD = 3\n    SINGLE_COLUMN_OF_TEXT_OF_VARIABLE_SIZES = 4\n    SINGLE_UNIFORM_BLOCK_OF_VERTICALLY_ALIGNED_TEXT = 5\n    SINGLE_UNIFORM_BLOCK_OF_TEXT = 6\n    SINGLE_TEXT_LINE = 7\n    SINGLE_WORD = 8",
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "SubtitleTypeFilter",
        "kind": 6,
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "peekOfCode": "class SubtitleTypeFilter(enum.Enum):\n    ALL = 'all'\n    FULL_ONLY = 'full-only'\n    FORCED_INCLUDED = 'forced-included'\n    FORCED_ONLY = 'forced-only'\n    SDH_INCLUDED = 'sdh-included'\n    SDH_ONLY = 'sdh-only'\n    ALL_INCLUDED = 'all-included'\nclass Options:\n    def __init__(self,",
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "kind": 6,
        "importPath": "pgsrip.options",
        "description": "pgsrip.options",
        "peekOfCode": "class Options:\n    def __init__(self,\n                 config_path: typing.Optional[str] = None,\n                 languages: typing.Optional[typing.Set[Language]] = None,\n                 tags: typing.Optional[typing.Set[str]] = None,\n                 encoding: typing.Optional[str] = None,\n                 overwrite=False,\n                 one_per_lang=True,\n                 keep_temp_files=False,\n                 max_workers: typing.Optional[int] = None,",
        "detail": "pgsrip.options",
        "documentation": {}
    },
    {
        "label": "SegmentType",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class SegmentType(enum.Enum):\n    PDS = int('0x14', 16)\n    ODS = int('0x15', 16)\n    PCS = int('0x16', 16)\n    WDS = int('0x17', 16)\n    END = int('0x80', 16)\n@enum.unique\nclass CompositionState(enum.Enum):\n    NORMAL_CASE = from_hex(b'\\x00')\n    ACQUISITION_POINT = from_hex(b'\\x40')",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "CompositionState",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class CompositionState(enum.Enum):\n    NORMAL_CASE = from_hex(b'\\x00')\n    ACQUISITION_POINT = from_hex(b'\\x40')\n    EPOCH_START = from_hex(b'\\x80')\n@enum.unique\nclass ObjectSequenceType(enum.Enum):\n    LAST = from_hex(b'\\x40')\n    FIRST = from_hex(b'\\x80')\n    FIRST_AND_LAST = from_hex(b'\\xc0')\nclass Palette(typing.NamedTuple):",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "ObjectSequenceType",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class ObjectSequenceType(enum.Enum):\n    LAST = from_hex(b'\\x40')\n    FIRST = from_hex(b'\\x80')\n    FIRST_AND_LAST = from_hex(b'\\xc0')\nclass Palette(typing.NamedTuple):\n    y: int\n    cr: int\n    cb: int\n    alpha: int\nclass PgsReader:",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "Palette",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class Palette(typing.NamedTuple):\n    y: int\n    cr: int\n    cb: int\n    alpha: int\nclass PgsReader:\n    @classmethod\n    def read_segments(cls, data: bytes, media_path: MediaPath):\n        count = 0\n        b = data",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "PgsReader",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class PgsReader:\n    @classmethod\n    def read_segments(cls, data: bytes, media_path: MediaPath):\n        count = 0\n        b = data\n        while b:\n            if b[:2] != b'PG':\n                logger.warning('%s Ignoring invalid PGS segment data: %s', media_path, b)\n                break\n            if len(b) < 13:",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "PgsImage",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class PgsImage:\n    def __init__(self, data: bytes, palettes: typing.List[Palette]):\n        self.rle_data = data\n        self.palettes = palettes\n        self._data: typing.Optional[ndarray] = None\n    @property\n    def data(self):\n        if self._data is None:\n            self._data = self.decode_rle_image(self.rle_data, self.palettes)\n        return self._data",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "BaseSegment",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class BaseSegment:\n    def __init__(self, b: bytes):\n        self.bytes = b\n    @property\n    def presentation_timestamp(self):\n        return to_time(from_hex(self.bytes[2:6]) / 90)\n    @property\n    def decoding_timestamp(self):\n        return to_time(from_hex(self.bytes[6:10]) / 90)\n    @property",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "PresentationCompositionSegment",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class PresentationCompositionSegment(BaseSegment):\n    @property\n    def width(self):\n        return from_hex(self.data[0:2])\n    @property\n    def height(self):\n        return from_hex(self.data[2:4])\n    @property\n    def frame_rate(self):\n        return self.data[4]",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "WindowDefinitionSegment",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class WindowDefinitionSegment(BaseSegment):\n    @property\n    def num_windows(self):\n        return self.data[0]\n    @property\n    def window_id(self):\n        return self.data[1]\n    @property\n    def x_offset(self):\n        return from_hex(self.data[2:4])",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "PaletteDefinitionSegment",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class PaletteDefinitionSegment(BaseSegment):\n    def __init__(self, b: bytes):\n        super().__init__(b)\n        self.palettes = [Palette(0, 0, 0, 0)] * 256\n        # Slice from byte 2 til end of segment. Divide by 5 to determine number of palette entries\n        # Iterate entries. Explode the 5 bytes into namedtuple Palette. Must be exploded\n        for entry in range(len(self.data[2:]) // 5):\n            i = 2 + entry * 5\n            self.palettes[self.data[i]] = Palette(*self.data[i + 1:i + 5])\n    @property",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "ObjectDefinitionSegment",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class ObjectDefinitionSegment(BaseSegment):\n    @property\n    def id(self):\n        return from_hex(self.data[0:2])\n    @property\n    def version(self):\n        return self.data[2]\n    @property\n    def sequence_type(self):\n        return ObjectSequenceType(self.data[3])",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "EndSegment",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class EndSegment(BaseSegment):\n    def attributes(self):\n        return {}\nSEGMENT_TYPE = {\n    SegmentType.PDS: PaletteDefinitionSegment,\n    SegmentType.ODS: ObjectDefinitionSegment,\n    SegmentType.PCS: PresentationCompositionSegment,\n    SegmentType.WDS: WindowDefinitionSegment,\n    SegmentType.END: EndSegment\n}",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "DisplaySet",
        "kind": 6,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "class DisplaySet:\n    def __init__(self, index: int, segments: typing.List[BaseSegment]):\n        self.index = index\n        self.segments = segments\n    @property\n    def pcs(self):\n        return [s for s in self.segments if isinstance(s, PresentationCompositionSegment)][0]\n    @property\n    def wds(self):\n        return [s for s in self.segments if isinstance(s, WindowDefinitionSegment)][0]",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@enum.unique\nclass SegmentType(enum.Enum):\n    PDS = int('0x14', 16)\n    ODS = int('0x15', 16)\n    PCS = int('0x16', 16)\n    WDS = int('0x17', 16)\n    END = int('0x80', 16)\n@enum.unique\nclass CompositionState(enum.Enum):",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "SEGMENT_TYPE",
        "kind": 5,
        "importPath": "pgsrip.pgs",
        "description": "pgsrip.pgs",
        "peekOfCode": "SEGMENT_TYPE = {\n    SegmentType.PDS: PaletteDefinitionSegment,\n    SegmentType.ODS: ObjectDefinitionSegment,\n    SegmentType.PCS: PresentationCompositionSegment,\n    SegmentType.WDS: WindowDefinitionSegment,\n    SegmentType.END: EndSegment\n}\nclass DisplaySet:\n    def __init__(self, index: int, segments: typing.List[BaseSegment]):\n        self.index = index",
        "detail": "pgsrip.pgs",
        "documentation": {}
    },
    {
        "label": "ImageArea",
        "kind": 6,
        "importPath": "pgsrip.ripper",
        "description": "pgsrip.ripper",
        "peekOfCode": "class ImageArea:\n    def __init__(self, items: typing.List[PgsSubtitleItem], gap: typing.Tuple[int, int]):\n        self.gap = gap\n        self.width = sum([(item.shape[3] - item.shape[1]) for item in items]) + (len(items) - 1) * gap[1]\n        self.shape = (\n            min([item.shape[0] for item in items]), items[0].shape[1],\n            max([item.shape[2] for item in items]), min([item.shape[1] for item in items]) + self.width)\n        self.items = items\n    def __str__(self):\n        return str(self.shape)",
        "detail": "pgsrip.ripper",
        "documentation": {}
    },
    {
        "label": "FullImage",
        "kind": 6,
        "importPath": "pgsrip.ripper",
        "description": "pgsrip.ripper",
        "peekOfCode": "class FullImage:\n    def __init__(self, areas: typing.List[ImageArea], gap: typing.Tuple[int, int]):\n        border = 100\n        total_height = sum([area.height for area in areas]) + (len(areas) - 1) * gap[0] + 2 * border\n        total_width = max([area.width for area in areas]) + 2 * border\n        full_image = np.full((total_height, total_width), 255, dtype=np.uint8)\n        h_start = border\n        w_start = border\n        for area in areas:\n            h_end = h_start + area.height",
        "detail": "pgsrip.ripper",
        "documentation": {}
    },
    {
        "label": "PgsToSrtRipper",
        "kind": 6,
        "importPath": "pgsrip.ripper",
        "description": "pgsrip.ripper",
        "peekOfCode": "class PgsToSrtRipper:\n    def __init__(self, pgs: Pgs, options: Options):\n        self.pgs = pgs\n        self.confidence = min(max(options.confidence or 65, 0), 100)\n        self.max_tess_width = min(max(options.tesseract_width or 31 * 1024, 10 * 1024), 31 * 1024)\n        self.omp_thread_limit = options.max_workers\n        self.oem = options.tesseract_oem or TesseractEngineMode.NEURAL\n        self.psm = options.tesseract_psm or TesseractPageSegmentationMode.SINGLE_UNIFORM_BLOCK_OF_TEXT\n        max_height = max([item.height for item in self.pgs.items]) // 2\n        self.gap = (max_height // 2 + 30, max_height // 2 + 100)",
        "detail": "pgsrip.ripper",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.ripper",
        "description": "pgsrip.ripper",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ImageArea:\n    def __init__(self, items: typing.List[PgsSubtitleItem], gap: typing.Tuple[int, int]):\n        self.gap = gap\n        self.width = sum([(item.shape[3] - item.shape[1]) for item in items]) + (len(items) - 1) * gap[1]\n        self.shape = (\n            min([item.shape[0] for item in items]), items[0].shape[1],\n            max([item.shape[2] for item in items]), min([item.shape[1] for item in items]) + self.width)\n        self.items = items\n    def __str__(self):",
        "detail": "pgsrip.ripper",
        "documentation": {}
    },
    {
        "label": "Sup",
        "kind": 6,
        "importPath": "pgsrip.sup",
        "description": "pgsrip.sup",
        "peekOfCode": "class Sup(Media):\n    def __init__(self, path: str):\n        media_path = MediaPath(path)\n        super().__init__(media_path, languages={media_path.language})\n    def get_pgs_medias(self, options: Options) -> Iterable[Pgs]:\n        temp_folder = self.media_path.create_temp_folder()\n        pgs = Pgs(self.media_path, options=options, data_reader=self.media_path.get_data, temp_folder=temp_folder)\n        if pgs.matches(options):\n            yield pgs",
        "detail": "pgsrip.sup",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "pgsrip.sup",
        "description": "pgsrip.sup",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass Sup(Media):\n    def __init__(self, path: str):\n        media_path = MediaPath(path)\n        super().__init__(media_path, languages={media_path.language})\n    def get_pgs_medias(self, options: Options) -> Iterable[Pgs]:\n        temp_folder = self.media_path.create_temp_folder()\n        pgs = Pgs(self.media_path, options=options, data_reader=self.media_path.get_data, temp_folder=temp_folder)\n        if pgs.matches(options):\n            yield pgs",
        "detail": "pgsrip.sup",
        "documentation": {}
    },
    {
        "label": "TsvDataItem",
        "kind": 6,
        "importPath": "pgsrip.tsv",
        "description": "pgsrip.tsv",
        "peekOfCode": "class TsvDataItem:\n    def __init__(self, level, page_num, block_num, par_num, line_num, word_num, left, top, width, height, conf, text):\n        self.level = int(level)\n        self.page_num = int(page_num)\n        self.block_num = int(block_num)\n        self.par_num = int(par_num)\n        self.line_num = int(line_num)\n        self.word_num = int(word_num)\n        self.left = int(left)\n        self.top = int(top)",
        "detail": "pgsrip.tsv",
        "documentation": {}
    },
    {
        "label": "TsvData",
        "kind": 6,
        "importPath": "pgsrip.tsv",
        "description": "pgsrip.tsv",
        "peekOfCode": "class TsvData:\n    def __init__(self, data: dict, confidence: int):\n        self.confidence = confidence\n        keys = data.keys()\n        items = [TsvDataItem(**{k: values[i] for (i, k) in enumerate(keys)}) for values in (\n            zip(*[data[key] for key in keys]))]\n        items.sort(key=lambda x: x.word_num)\n        items.sort(key=lambda x: x.line_num)\n        items.sort(key=lambda x: x.par_num)\n        items.sort(key=lambda x: x.block_num)",
        "detail": "pgsrip.tsv",
        "documentation": {}
    },
    {
        "label": "from_hex",
        "kind": 2,
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "peekOfCode": "def from_hex(b: bytes):\n    return int(b.hex(), base=16)\ndef safe_get(b: bytes, i: int, default_value=0):\n    try:\n        return b[i]\n    except IndexError:\n        return default_value\ndef to_time(value: typing.Optional[int]):\n    return SubRipTime.from_ordinal(value) if value else None\nT = typing.TypeVar('T')",
        "detail": "pgsrip.utils",
        "documentation": {}
    },
    {
        "label": "safe_get",
        "kind": 2,
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "peekOfCode": "def safe_get(b: bytes, i: int, default_value=0):\n    try:\n        return b[i]\n    except IndexError:\n        return default_value\ndef to_time(value: typing.Optional[int]):\n    return SubRipTime.from_ordinal(value) if value else None\nT = typing.TypeVar('T')\ndef pairwise(iterable: typing.Iterable[T]) -> typing.Iterable[typing.Tuple[T, typing.Optional[T]]]:\n    \"\"\"s -> (s0, s1), (s1, s2), (s2, s3), (s2, None)\"\"\"",
        "detail": "pgsrip.utils",
        "documentation": {}
    },
    {
        "label": "to_time",
        "kind": 2,
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "peekOfCode": "def to_time(value: typing.Optional[int]):\n    return SubRipTime.from_ordinal(value) if value else None\nT = typing.TypeVar('T')\ndef pairwise(iterable: typing.Iterable[T]) -> typing.Iterable[typing.Tuple[T, typing.Optional[T]]]:\n    \"\"\"s -> (s0, s1), (s1, s2), (s2, s3), (s2, None)\"\"\"\n    it = iter(iterable)\n    a = next(it, None)\n    if a is not None:\n        for b in it:\n            yield a, b",
        "detail": "pgsrip.utils",
        "documentation": {}
    },
    {
        "label": "pairwise",
        "kind": 2,
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "peekOfCode": "def pairwise(iterable: typing.Iterable[T]) -> typing.Iterable[typing.Tuple[T, typing.Optional[T]]]:\n    \"\"\"s -> (s0, s1), (s1, s2), (s2, s3), (s2, None)\"\"\"\n    it = iter(iterable)\n    a = next(it, None)\n    if a is not None:\n        for b in it:\n            yield a, b\n            a = b\n        yield a, None",
        "detail": "pgsrip.utils",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "pgsrip.utils",
        "description": "pgsrip.utils",
        "peekOfCode": "T = typing.TypeVar('T')\ndef pairwise(iterable: typing.Iterable[T]) -> typing.Iterable[typing.Tuple[T, typing.Optional[T]]]:\n    \"\"\"s -> (s0, s1), (s1, s2), (s2, s3), (s2, None)\"\"\"\n    it = iter(iterable)\n    a = next(it, None)\n    if a is not None:\n        for b in it:\n            yield a, b\n            a = b\n        yield a, None",
        "detail": "pgsrip.utils",
        "documentation": {}
    }
]